<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dreamy Heart</title>
  <style>
    :root{
      --bg1:#0b1026;
      --bg2:#170b2a;
      --heart:#ff3b6b;
      --cycle: 1.2s;
      --size: 180px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(1200px 800px at 50% 40%, rgba(255,70,130,.16), transparent 60%),
        linear-gradient(145deg, var(--bg1), var(--bg2));
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
      user-select:none;
    }

    /* ç²’å­ç”»å¸ƒï¼šå…¨å±è¦†ç›– */
    #fx{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      z-index:0;
      pointer-events:none;
    }

    /* çˆ±å¿ƒï¼šå±…ä¸­æ— é®æŒ¡ + æ¢¦å¹»å‘¼å¸å…‰ */
    .heart{
      position:relative;
      z-index:1;
      width: var(--size);
      height: var(--size);
      transform: rotate(45deg);
      background: var(--heart);
      border-radius: 18px;
      cursor:pointer;

      animation: heartbeat var(--cycle) infinite, glow 2.2s ease-in-out infinite;
      transform-origin: 50% 60%;
      will-change: transform, filter;
    }
    .heart::before,
    .heart::after{
      content:"";
      position:absolute;
      width: var(--size);
      height: var(--size);
      background: var(--heart);
      border-radius: 50%;
    }
    .heart::before{ left: -50%; top: 0; }
    .heart::after { left: 0; top: -50%; }

    @keyframes heartbeat{
      0%   { transform: rotate(45deg) scale(1) translateY(0); }
      10%  { transform: rotate(45deg) scale(1.08) translateY(-2px); }
      18%  { transform: rotate(45deg) scale(0.98) translateY(0); }
      26%  { transform: rotate(45deg) scale(1.04) translateY(-1px); }
      34%  { transform: rotate(45deg) scale(1) translateY(0); }
      100% { transform: rotate(45deg) scale(1) translateY(0); }
    }
    @keyframes glow{
      0%,100% { filter: drop-shadow(0 0 18px rgba(255,122,168,.22)) drop-shadow(0 0 45px rgba(255,59,107,.10)); }
      50%     { filter: drop-shadow(0 0 26px rgba(255,122,168,.30)) drop-shadow(0 0 70px rgba(255,59,107,.14)); }
    }

    /* å”¯ä¸€æç¤ºï¼šç‚¹ä¸€ç‚¹ï¼ˆæ›´æ¢¦å¹»ï¼šè½»å¾®å‘¼å¸ï¼‰ */
    .tip{
      position:fixed;
      left:50%;
      bottom:26px;
      transform:translateX(-50%);
      z-index:2;
      font-size:14px;
      letter-spacing:.22em;
      color: rgba(255,255,255,.72);
      text-shadow: 0 6px 28px rgba(0,0,0,.35);
      pointer-events:none;
      animation: tipBreath 1.8s ease-in-out infinite;
    }
    @keyframes tipBreath{
      0%,100%{ opacity:.55; transform:translateX(-50%) translateY(0); }
      50%    { opacity:.85; transform:translateX(-50%) translateY(-1px); }
    }
  </style>
</head>

<body>
  <canvas id="fx"></canvas>
  <div id="heart" class="heart" aria-label="heart"></div>
  <div class="tip"></div>

  <script>
    /***********************
     *  Dreamy Canvas FXï¼ˆè½»é‡ + é˜²å¡ï¼‰
     ***********************/
    const canvas = document.getElementById('fx');
    const ctx = canvas.getContext('2d', { alpha: true });
    const heartEl = document.getElementById('heart');

    let W = 0, H = 0, DPR = 1;

    function resize(){
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      DPR = Math.max(1, Math.min(2.0, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // resize æ—¶å½»åº•æ¸…ä¸€æ¬¡ï¼Œé¿å…æ‹–å°¾æ®‹ç•™
      ctx.clearRect(0, 0, W, H);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // å¿ƒå½¢å‚æ•°æ–¹ç¨‹
    function heartPoint(t){
      const s = Math.sin(t);
      const c = Math.cos(t);
      const x = 16 * s * s * s;
      const y = 13 * c - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      return { x, y };
    }

    function getHeartCenter(){
      const r = heartEl.getBoundingClientRect();
      return { cx: r.left + r.width/2, cy: r.top + r.height/2, r };
    }

    function rand(a,b){ return a + Math.random()*(b-a); }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    // âœ… ç²’å­ä¸Šé™ï¼ˆæ›´ä¸¥æ ¼æ›´ç¨³ï¼‰
    const MAX_PARTICLES = 850;

    const particles = [];
    const palette = [
      "rgba(255,59,107,1)",
      "rgba(255,122,168,1)",
      "rgba(255,203,221,1)"
    ];

    // è¿·ä½ çˆ±å¿ƒ Path2Dï¼ˆçœæ€§èƒ½ï¼‰
    const miniHeartPath = new Path2D();
    miniHeartPath.moveTo(0, 0.35);
    miniHeartPath.bezierCurveTo(0, 0, -0.55, 0, -0.55, 0.35);
    miniHeartPath.bezierCurveTo(-0.55, 0.75, 0, 0.95, 0, 1.2);
    miniHeartPath.bezierCurveTo(0, 0.95, 0.55, 0.75, 0.55, 0.35);
    miniHeartPath.bezierCurveTo(0.55, 0, 0, 0, 0, 0.35);
    miniHeartPath.closePath();

    function pushParticle(p){
      particles.push(p);
      if(particles.length > MAX_PARTICLES){
        particles.splice(0, particles.length - MAX_PARTICLES); // ä¸¢æ—§çš„ä¿æ–°çš„
      }
    }

    // æ¢¦å¹»å¢å¼ºï¼šèƒŒæ™¯ bokehï¼ˆå¾ˆå°‘ã€å¾ˆæ…¢ã€å¾ˆæ·¡ï¼‰
    const bokeh = [];
    const BOKEH_N = 18;
    function initBokeh(){
      bokeh.length = 0;
      for(let i=0;i<BOKEH_N;i++){
        bokeh.push({
          x: Math.random()*W,
          y: Math.random()*H,
          r: rand(18, 55),
          a: rand(0.04, 0.10),
          vx: rand(-6, 6)/60,
          vy: rand(-4, 4)/60,
          tw: Math.random()*Math.PI*2,
        });
      }
    }
    initBokeh();

    // ç²’å­å‘å°„ï¼šæ›´æ¢¦å¹»=æ›´è½»æ›´æŸ”ï¼ˆå¹¶å¸¦â€œé¢„ç®—ç¼©æ”¾â€ï¼‰
    function spawnBurst(strength = 1){
      const budget = clamp01((MAX_PARTICLES - particles.length) / MAX_PARTICLES);
      // ç²’å­å¤šäº†å°±è‡ªåŠ¨å°‘å–·ï¼ˆé˜²å¡æ­»ï¼‰
      const eff = strength * Math.max(0.25, budget);

      const { cx, cy, r } = getHeartCenter();
      const scale = (Math.min(r.width, r.height) / 40) * 1.05;

      const count = Math.floor(18 * eff);          // æ›´å°‘
      const jitter = 0.30;
      const speedMin = 55, speedMax = 130;         // æ›´æ…¢æ›´é£˜
      const ttlMin = 0.55, ttlMax = 1.10;          // ç¨é•¿ä¸€ç‚¹æ›´â€œé›¾â€
      const gMin = 70, gMax = 160;                 // æ›´è½»

      for(let i=0; i<count; i++){
        const t = Math.random() * Math.PI * 2;
        const hp = heartPoint(t);

        const px = cx + hp.x * scale;
        const py = cy - hp.y * scale;

        let dx = px - cx, dy = py - cy;
        const len = Math.hypot(dx, dy) || 1;
        dx /= len; dy /= len;

        const speed = rand(speedMin, speedMax) * eff;

        pushParticle({
          x: px + rand(-1.2, 1.2),
          y: py + rand(-1.2, 1.2),
          vx: (dx + rand(-jitter, jitter)) * speed / 60,
          vy: (dy + rand(-jitter, jitter)) * speed / 60,
          g: rand(gMin, gMax) / 60,
          drag: rand(0.990, 0.997),
          life: 0,
          ttl: rand(ttlMin, ttlMax),
          size: rand(1.0, 2.3),
          rot: rand(0, Math.PI*2),
          spin: rand(-2.2, 2.2),
          color: palette[Math.floor(Math.random()*palette.length)],
        });
      }
    }

    // å°â€œæ˜Ÿå°˜â€ç‚¹ç¼€ï¼šæ¯å¸§å°‘é‡ç”Ÿæˆ 1~2 ç²’ï¼ˆéå¸¸è½»ï¼‰
    function spawnSparkle(){
      const budget = clamp01((MAX_PARTICLES - particles.length) / MAX_PARTICLES);
      if(budget < 0.15) return; // ç²’å­å¤ªå¤šæ—¶ä¸åŠ æ˜Ÿå°˜

      const { cx, cy, r } = getHeartCenter();
      const scale = (Math.min(r.width, r.height) / 40) * 1.05;
      const n = (Math.random() < 0.6) ? 1 : 2;

      for(let i=0;i<n;i++){
        const t = Math.random() * Math.PI * 2;
        const hp = heartPoint(t);
        const px = cx + hp.x * scale;
        const py = cy - hp.y * scale;

        const speed = rand(25, 70);
        const ang = rand(0, Math.PI*2);

        pushParticle({
          x: px + rand(-1, 1),
          y: py + rand(-1, 1),
          vx: Math.cos(ang) * speed / 60,
          vy: Math.sin(ang) * speed / 60,
          g: rand(25, 60) / 60,
          drag: rand(0.992, 0.998),
          life: 0,
          ttl: rand(0.50, 0.85),
          size: rand(0.8, 1.6),
          rot: rand(0, Math.PI*2),
          spin: rand(-1.8, 1.8),
          color: "rgba(255,255,255,1)",
        });
      }
    }

    function drawMiniHeart(x, y, s, rot, color, alpha){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.scale(s, s);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fill(miniHeartPath);
      ctx.restore();
    }

    let last = performance.now();

    function tick(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      // ğŸŒ«ï¸ æ¢¦å¹»æ‹–å°¾ï¼šç”¨åŠé€æ˜â€œé›¾å±‚â€æ“¦é™¤ï¼Œè€Œä¸æ˜¯ clearRect
      // alpha è¶Šå°æ‹–å°¾è¶Šé•¿ï¼ˆå»ºè®® 0.10~0.18ï¼‰
      ctx.save();
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgba(11,16,38,0.13)";
      ctx.fillRect(0, 0, W, H);
      ctx.restore();

      // èƒŒæ™¯ bokehï¼šæ·¡æ·¡æ¼‚æµ®
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.shadowBlur = 30;
      ctx.shadowColor = "rgba(255,122,168,.18)";
      for(const b of bokeh){
        b.x += b.vx * 60 * dt;
        b.y += b.vy * 60 * dt;
        b.tw += 0.6 * dt;

        // è¾¹ç•Œå¾ªç¯
        if(b.x < -80) b.x = W + 80;
        if(b.x > W + 80) b.x = -80;
        if(b.y < -80) b.y = H + 80;
        if(b.y > H + 80) b.y = -80;

        const a = b.a * (0.75 + 0.25 * Math.sin(b.tw));
        ctx.globalAlpha = a;
        ctx.fillStyle = "rgba(255,122,168,1)";
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // æ˜Ÿå°˜ç‚¹ç¼€ï¼ˆéå¸¸è½»ï¼‰
      if(Math.random() < 0.22) spawnSparkle();

      // ç²’å­ä¸»ä½“
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.shadowBlur = 14;
      ctx.shadowColor = "rgba(255,122,168,.22)";

      for(let i = particles.length - 1; i >= 0; i--){
        const p = particles[i];
        p.life += dt;

        p.vx *= Math.pow(p.drag, 60*dt);
        p.vy *= Math.pow(p.drag, 60*dt);
        p.vy += p.g * dt;

        p.x += p.vx * 60 * dt;
        p.y += p.vy * 60 * dt;

        p.rot += p.spin * dt;

        const t = p.life / p.ttl;
        if(t >= 1){
          particles.splice(i, 1);
          continue;
        }

        // æ›´æ¢¦å¹»ï¼šå‰æœŸäº®ï¼ŒåæœŸæ…¢æ…¢æ·¡
        const alpha = (1 - t) * (0.55 + 0.20*(1 - t));

        drawMiniHeart(p.x, p.y, p.size, p.rot, p.color, alpha);
      }

      ctx.restore();
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    /***********************
     *  å¿ƒè·³å–·ç²’ï¼ˆæ›´æŸ”ï¼‰
     ***********************/
    const cycleMs = 1200;
    function startHeartBeats(){
      function loop(){
        spawnBurst(0.28);
        setTimeout(() => spawnBurst(0.18), 200);
        setTimeout(loop, cycleMs);
      }
      loop();
    }
    startHeartBeats();

    /***********************
     *  ç‚¹å‡»ï¼šè½»å–· + å†·å´ï¼ˆé˜²ç‹‚ç‚¹ï¼‰
     ***********************/
    const CLICK_COOLDOWN_MS = 220;
    let lastClick = 0;

    heartEl.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      const now = performance.now();
      if(now - lastClick < CLICK_COOLDOWN_MS) return;
      lastClick = now;

      spawnBurst(0.55);
    });

    // åˆå§‹åŒ– bokeh åœ¨ resize åæ›´æ–°
    window.addEventListener('resize', () => initBokeh(), { passive:true });

  })();
  </script>
</body>
</html>
