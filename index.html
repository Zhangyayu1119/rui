<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Heart</title>
  <style>
    :root{
      --bg1:#0b1026;
      --bg2:#170b2a;
      --heart:#ff3b6b;
      --cycle: 1.2s;
      --size: 180px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(1200px 800px at 50% 40%, rgba(255,70,130,.16), transparent 60%),
        linear-gradient(145deg, var(--bg1), var(--bg2));
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
      user-select:none;
    }

    /* 粒子画布：全屏覆盖 */
    #fx{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      z-index:0;
      pointer-events:none;
    }

    /* 爱心：居中，无遮挡 */
    .heart{
      position:relative;
      z-index:1;
      width: var(--size);
      height: var(--size);
      transform: rotate(45deg);
      background: var(--heart);
      border-radius: 18px;
      filter: drop-shadow(0 0 22px rgba(255, 80, 150, .25));
      cursor:pointer;

      animation: heartbeat var(--cycle) infinite;
      transform-origin: 50% 60%;
    }
    .heart::before,
    .heart::after{
      content:"";
      position:absolute;
      width: var(--size);
      height: var(--size);
      background: var(--heart);
      border-radius: 50%;
    }
    .heart::before{ left: -50%; top: 0; }
    .heart::after { left: 0; top: -50%; }

    @keyframes heartbeat{
      0%   { transform: rotate(45deg) scale(1) translateY(0); }
      10%  { transform: rotate(45deg) scale(1.08) translateY(-2px); }
      18%  { transform: rotate(45deg) scale(0.98) translateY(0); }
      26%  { transform: rotate(45deg) scale(1.04) translateY(-1px); }
      34%  { transform: rotate(45deg) scale(1) translateY(0); }
      100% { transform: rotate(45deg) scale(1) translateY(0); }
    }

    /* 唯一提示：点一点（极简、轻） */
    .tip{
      position:fixed;
      left:50%;
      bottom:26px;
      transform:translateX(-50%);
      z-index:2;
      font-size:14px;
      letter-spacing:.2em;
      color: rgba(255,255,255,.72);
      text-shadow: 0 6px 28px rgba(0,0,0,.35);
      pointer-events:none;
    }
  </style>
</head>

<body>
  <canvas id="fx"></canvas>
  <div id="heart" class="heart" aria-label="heart"></div>
  <div class="tip">点一点</div>

  <script>
    /***********************
     *  Canvas 粒子系统（轻量防卡）
     ***********************/
    const canvas = document.getElementById('fx');
    const ctx = canvas.getContext('2d', { alpha: true });
    const heartEl = document.getElementById('heart');

    let W = 0, H = 0, DPR = 1;

    function resize(){
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      DPR = Math.max(1, Math.min(2.0, window.devicePixelRatio || 1)); // 稍微压一下 DPR，省性能
      canvas.width  = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // 心形参数方程
    function heartPoint(t){
      const s = Math.sin(t);
      const c = Math.cos(t);
      const x = 16 * s * s * s;
      const y = 13 * c - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      return { x, y };
    }

    function getHeartCenter(){
      const r = heartEl.getBoundingClientRect();
      return { cx: r.left + r.width/2, cy: r.top + r.height/2, r };
    }

    // ✅ 粒子上限（防止狂点卡死）
    const MAX_PARTICLES = 900;

    const particles = [];
    const palette = [
      "rgba(255,59,107,1)",
      "rgba(255,122,168,1)",
      "rgba(255,203,221,1)"
    ];

    function rand(a,b){ return a + Math.random()*(b-a); }

    // 预生成一个“迷你爱心路径”，避免每帧重复写 bezier（省性能）
    const miniHeartPath = new Path2D();
    // 基于单位尺寸 k=1 的形状（后面用 scale 放大/缩小）
    miniHeartPath.moveTo(0, 0.35);
    miniHeartPath.bezierCurveTo(0, 0, -0.55, 0, -0.55, 0.35);
    miniHeartPath.bezierCurveTo(-0.55, 0.75, 0, 0.95, 0, 1.2);
    miniHeartPath.bezierCurveTo(0, 0.95, 0.55, 0.75, 0.55, 0.35);
    miniHeartPath.bezierCurveTo(0.55, 0, 0, 0, 0, 0.35);
    miniHeartPath.closePath();

    function pushParticle(p){
      particles.push(p);
      // 超过上限就丢弃最旧的，保证不卡
      if(particles.length > MAX_PARTICLES){
        particles.splice(0, particles.length - MAX_PARTICLES);
      }
    }

    // ✅ 削弱粒子：数量更少、速度更慢、寿命更短、更淡
    function spawnBurst(strength = 1){
      const { cx, cy, r } = getHeartCenter();
      const scale = (Math.min(r.width, r.height) / 40) * 1.05;

      const count = Math.floor(22 * strength);   // ⬅️ 原来 70，砍到很轻
      const jitter = 0.35;                       // ⬅️ 扰动更小
      const speedMin = 70, speedMax = 160;       // ⬅️ 速度更慢

      for(let i=0; i<count; i++){
        const t = Math.random() * Math.PI * 2;
        const p = heartPoint(t);

        const px = cx + p.x * scale;
        const py = cy - p.y * scale;

        let dx = px - cx, dy = py - cy;
        const len = Math.hypot(dx, dy) || 1;
        dx /= len; dy /= len;

        const speed = rand(speedMin, speedMax) * strength;

        pushParticle({
          x: px + rand(-1.5, 1.5),
          y: py + rand(-1.5, 1.5),
          vx: (dx + rand(-jitter, jitter)) * speed / 60,
          vy: (dy + rand(-jitter, jitter)) * speed / 60,
          g: rand(120, 220) / 60,               // ⬅️ 重力更小
          drag: rand(0.988, 0.996),             // ⬅️ 更快衰减
          life: 0,
          ttl: rand(0.45, 0.85) * (1.05/strength), // ⬅️ 更短寿命
          size: rand(1.2, 2.4) * (1 + 0.15*strength),
          rot: rand(0, Math.PI*2),
          spin: rand(-3, 3),
          color: palette[Math.floor(Math.random()*palette.length)],
        });
      }
    }

    function drawMiniHeart(x, y, s, rot, color, alpha){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.scale(s, s);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fill(miniHeartPath);
      ctx.restore();
    }

    let last = performance.now();

    function tick(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      ctx.clearRect(0, 0, W, H);

      // 更轻的发光（防过曝 + 省性能）
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "rgba(255,122,168,.22)";

      for(let i = particles.length - 1; i >= 0; i--){
        const p = particles[i];
        p.life += dt;

        p.vx *= Math.pow(p.drag, 60*dt);
        p.vy *= Math.pow(p.drag, 60*dt);
        p.vy += p.g * dt;

        p.x += p.vx * 60 * dt;
        p.y += p.vy * 60 * dt;

        p.rot += p.spin * dt;

        const t = p.life / p.ttl;
        const alpha = (1 - t) * 0.75; // ⬅️ 更淡

        if(t >= 1){
          particles.splice(i, 1);
          continue;
        }

        drawMiniHeart(p.x, p.y, p.size, p.rot, p.color, alpha);
      }

      ctx.restore();
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    /***********************
     *  心跳喷粒（更弱）
     ***********************/
    const cycleMs = 1200;
    function startHeartBeats(){
      function loop(){
        // ⬅️ 原来 1.0 + 0.65，改成更轻
        spawnBurst(0.35);
        setTimeout(() => spawnBurst(0.22), 200);
        setTimeout(loop, cycleMs);
      }
      loop();
    }
    startHeartBeats();

    /***********************
     *  点击：轻喷 + 冷却（防狂点卡死）
     ***********************/
    const CLICK_COOLDOWN_MS = 220;
    let lastClick = 0;

    heartEl.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      const now = performance.now();
      if(now - lastClick < CLICK_COOLDOWN_MS) return; // ⬅️ 冷却
      lastClick = now;

      // 轻量点击效果（不再 bigBoom 连发）
      spawnBurst(0.65);
    });
  </script>
</body>
</html>
