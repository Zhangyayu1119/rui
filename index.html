<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Particle Heart</title>
  <style>
    :root{
      --bg1:#0b1026;
      --bg2:#170b2a;
    }
    html, body { height:100%; margin:0; }
    body{
      overflow:hidden;
      background:
        radial-gradient(1100px 760px at 50% 40%, rgba(255,70,130,.14), transparent 60%),
        linear-gradient(145deg, var(--bg1), var(--bg2));
    }
    canvas{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      display:block;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  // =========================
  // 1) 自适应画布（DPR）
  // =========================
  let W=0, H=0, DPR=1;
  function resize(){
    W = window.innerWidth;
    H = window.innerHeight;
    DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize, { passive:true });
  resize();

  // =========================
  // 2) 心形参数方程（你之前喜欢的那种形状）
  //    x = 16 sin^3(t)
  //    y = 13 cos(t) - 5 cos(2t) - 2 cos(3t) - cos(4t)
  // =========================
  function heartPoint(t){
    const s = Math.sin(t), c = Math.cos(t);
    const x = 16 * s * s * s;
    const y = 13 * c - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    return { x, y };
  }

  // =========================
  // 3) 心跳因子（双击跳节奏，过程不停）
  //    模拟 CSS keyframe：1 -> 1.10 -> 0.98 -> 1.05 -> 1
  // =========================
  const beatPeriod = 1100; // ms（你想更快就改小）
  const beatKeys = [
    { t: 0.00, v: 1.00 },
    { t: 0.10, v: 1.10 },
    { t: 0.18, v: 0.98 },
    { t: 0.26, v: 1.05 },
    { t: 0.34, v: 1.00 },
    { t: 1.00, v: 1.00 },
  ];
  function heartbeatFactor(ms){
    const u = (ms % beatPeriod) / beatPeriod;
    for(let i=0;i<beatKeys.length-1;i++){
      const a = beatKeys[i], b = beatKeys[i+1];
      if(u >= a.t && u <= b.t){
        const k = (u - a.t) / Math.max(1e-6, (b.t - a.t));
        return a.v + (b.v - a.v) * k;
      }
    }
    return 1.0;
  }

  // =========================
  // 4) 粒子“出现 -> 消散（不完全）-> 再出现”的循环
  //    轮廓粒子常驻（隐约可见），填充粒子周期性出现/消散
  // =========================
  const palette = [
    "rgba(255,59,107,1)",
    "rgba(255,122,168,1)",
    "rgba(255,203,221,1)",
    "rgba(255,255,255,1)"
  ];

  // 轮廓粒子（常驻，隐约可见）
  const outline = [];
  const OUTLINE_N = 520;

  // 填充粒子（周期出现/消散）
  let fill = [];
  let cycleIndex = -1;

  // 周期设置：出现 -> 维持 -> 消散 -> 空窗（只剩轮廓）
  const cycleLen = 2600;       // ms
  const appearDur = 650;       // ms
  const holdDur   = 650;       // ms
  const fadeDur   = 1050;      // ms
  // 剩下的就是空窗（只剩轮廓）

  // ease
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const easeOutCubic = (x) => 1 - Math.pow(1 - x, 3);
  const easeInCubic  = (x) => x*x*x;

  // 心形在屏幕上的尺度（自适应）
  function baseScale(){
    return Math.min(W, H) * 0.018; // 经验值：越大心越大
  }

  function initOutline(){
    outline.length = 0;
    for(let i=0;i<OUTLINE_N;i++){
      const t = (i/OUTLINE_N) * Math.PI * 2;
      outline.push({
        t,
        jitter: (Math.random()*2 - 1) * 0.02,
        size: 1.2 + Math.random()*1.8,
        tw: Math.random()*Math.PI*2,
        col: palette[Math.floor(Math.random()*2)], // 更偏粉红
      });
    }
  }

  // 用“边界点缩放到中心”的方式生成内部点（稳定且形状贴合）
  function initFill(){
    fill = [];
    // 数量随屏幕大小轻微变化（不会炸性能）
    const N = Math.floor(1100 + Math.min(W, H) * 0.9);
    for(let i=0;i<N;i++){
      const t = Math.random() * Math.PI * 2;
      const b = heartPoint(t);
      // k 用 sqrt 随机让分布更像“面积均匀”
      const k = Math.sqrt(Math.random());
      const x0 = b.x * k;
      const y0 = b.y * k;

      // 轻微的粒子随机初始偏移（更“粒子感”）
      const n = 0.18;
      fill.push({
        x0: x0 + (Math.random()*2-1)*n,
        y0: y0 + (Math.random()*2-1)*n,
        // 消散时的飘散方向（从中心向外 + 一点随机）
        dx: 0,
        dy: 0,
        seed: Math.random()*1000,
        size: 1.0 + Math.random()*2.2,
        col: palette[Math.floor(Math.random()*palette.length)],
      });
    }

    // 预计算飘散方向：从原点指向该点（归一化）+ 随机扰动
    for(const p of fill){
      let dx = p.x0, dy = p.y0;
      const len = Math.hypot(dx, dy) || 1;
      dx /= len; dy /= len;
      dx += (Math.random()*2-1)*0.25;
      dy += (Math.random()*2-1)*0.25;
      const len2 = Math.hypot(dx, dy) || 1;
      p.dx = dx/len2;
      p.dy = dy/len2;
    }
  }

  initOutline();
  initFill();

  // =========================
  // 5) 渲染：轮廓常驻 + 填充粒子周期出现/消散
  // =========================
  function draw(now){
    // 背景清屏（想要更梦幻拖影：把 alpha 改成 0.10~0.18）
    ctx.clearRect(0, 0, W, H);

    const cx = W/2,
