<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dreamy Heart</title>
  <style>
    :root{
      --bg:#0b1026;           /* ✅ 更纯色背景 */
      --heart:#ff3b6b;
      --cycle: 1.2s;
      --size: 180px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      background: var(--bg);  /* ✅ 纯色 */
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", Arial, sans-serif;
      user-select:none;
    }

    /* 粒子画布：全屏覆盖 */
    #fx{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      z-index:0;
      pointer-events:none;
    }

    /* 爱心：居中无遮挡 + 梦幻呼吸光（但不需要交互） */
    .heart{
      position:relative;
      z-index:1;
      width: var(--size);
      height: var(--size);
      transform: rotate(45deg);
      background: var(--heart);
      border-radius: 18px;

      animation: heartbeat var(--cycle) infinite, glow 2.2s ease-in-out infinite;
      transform-origin: 50% 60%;
      will-change: transform, filter;
    }
    .heart::before,
    .heart::after{
      content:"";
      position:absolute;
      width: var(--size);
      height: var(--size);
      background: var(--heart);
      border-radius: 50%;
    }
    .heart::before{ left: -50%; top: 0; }
    .heart::after { left: 0; top: -50%; }

    @keyframes heartbeat{
      0%   { transform: rotate(45deg) scale(1) translateY(0); }
      10%  { transform: rotate(45deg) scale(1.08) translateY(-2px); }
      18%  { transform: rotate(45deg) scale(0.98) translateY(0); }
      26%  { transform: rotate(45deg) scale(1.04) translateY(-1px); }
      34%  { transform: rotate(45deg) scale(1) translateY(0); }
      100% { transform: rotate(45deg) scale(1) translateY(0); }
    }
    @keyframes glow{
      0%,100% { filter: drop-shadow(0 0 16px rgba(255,122,168,.20)) drop-shadow(0 0 44px rgba(255,59,107,.08)); }
      50%     { filter: drop-shadow(0 0 24px rgba(255,122,168,.28)) drop-shadow(0 0 64px rgba(255,59,107,.12)); }
    }

    /* 可选提示：如果你也想更极简，可直接删掉这个 div */
    .tip{
      position:fixed;
      left:50%;
      bottom:26px;
      transform:translateX(-50%);
      z-index:2;
      font-size:14px;
      letter-spacing:.22em;
      color: rgba(255,255,255,.62);
      text-shadow: 0 6px 28px rgba(0,0,0,.35);
      pointer-events:none;
      animation: tipBreath 2.2s ease-in-out infinite;
    }
    @keyframes tipBreath{
      0%,100%{ opacity:.30; transform:translateX(-50%) translateY(0); }
      50%    { opacity:.65; transform:translateX(-50%) translateY(-1px); }
    }
  </style>
</head>

<body>
  <canvas id="fx"></canvas>
  <div id="heart" class="heart" aria-label="heart"></div>
  <div class="tip"></div>

  <script>
  (() => {
    const canvas = document.getElementById('fx');
    const ctx = canvas.getContext('2d', { alpha: true });
    const heartEl = document.getElementById('heart');

    let W=0, H=0, DPR=1;

    function resize(){
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      DPR = Math.max(1, Math.min(2.0, window.devicePixelRatio || 1));
      canvas.width  = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      ctx.clearRect(0, 0, W, H);
    }
    window.addEventListener('resize', resize, { passive:true });
    resize();

    // 心形参数方程
    function heartPoint(t){
      const s = Math.sin(t);
      const c = Math.cos(t);
      const x = 16 * s * s * s;
      const y = 13 * c - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
      return { x, y };
    }

    function getHeartCenter(){
      const r = heartEl.getBoundingClientRect();
      return { cx: r.left + r.width/2, cy: r.top + r.height/2, r };
    }

    function rand(a,b){ return a + Math.random()*(b-a); }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    // 粒子上限（稳）
    const MAX_PARTICLES = 850;
    const particles = [];
    const palette = [
      "rgba(255,59,107,1)",
      "rgba(255,122,168,1)",
      "rgba(255,203,221,1)"
    ];

    // 迷你爱心 Path2D（省性能）
    const miniHeartPath = new Path2D();
    miniHeartPath.moveTo(0, 0.35);
    miniHeartPath.bezierCurveTo(0, 0, -0.55, 0, -0.55, 0.35);
    miniHeartPath.bezierCurveTo(-0.55, 0.75, 0, 0.95, 0, 1.2);
    miniHeartPath.bezierCurveTo(0, 0.95, 0.55, 0.75, 0.55, 0.35);
    miniHeartPath.bezierCurveTo(0.55, 0, 0, 0, 0, 0.35);
    miniHeartPath.closePath();

    function pushParticle(p){
      particles.push(p);
      if(particles.length > MAX_PARTICLES){
        particles.splice(0, particles.length - MAX_PARTICLES);
      }
    }

    // 背景 bokeh（少量、淡淡、很省）
    const bokeh = [];
    const BOKEH_N = 14; // ✅ 背景更纯色：减少数量
    function initBokeh(){
      bokeh.length = 0;
      for(let i=0;i<BOKEH_N;i++){
        bokeh.push({
          x: Math.random()*W,
          y: Math.random()*H,
          r: rand(16, 44),
          a: rand(0.03, 0.07),
          vx: rand(-5, 5)/60,
          vy: rand(-3, 3)/60,
          tw: Math.random()*Math.PI*2,
        });
      }
    }
    initBokeh();

    // 粒子发射（仅自动心跳）
    function spawnBurst(strength = 1){
      const budget = clamp01((MAX_PARTICLES - particles.length) / MAX_PARTICLES);
      const eff = strength * Math.max(0.25, budget);

      const { cx, cy, r } = getHeartCenter();
      const scale = (Math.min(r.width, r.height) / 40) * 1.05;

      const count = Math.floor(16 * eff);   // ✅ 稍微更少
      const jitter = 0.28;
      const speedMin = 50, speedMax = 120;
      const ttlMin = 0.60, ttlMax = 1.10;
      const gMin = 60, gMax = 140;

      for(let i=0; i<count; i++){
        const t = Math.random() * Math.PI * 2;
        const hp = heartPoint(t);

        const px = cx + hp.x * scale;
        const py = cy - hp.y * scale;

        let dx = px - cx, dy = py - cy;
        const len = Math.hypot(dx, dy) || 1;
        dx /= len; dy /= len;

        const speed = rand(speedMin, speedMax) * eff;

        pushParticle({
          x: px + rand(-1.1, 1.1),
          y: py + rand(-1.1, 1.1),
          vx: (dx + rand(-jitter, jitter)) * speed / 60,
          vy: (dy + rand(-jitter, jitter)) * speed / 60,
          g: rand(gMin, gMax) / 60,
          drag: rand(0.990, 0.997),
          life: 0,
          ttl: rand(ttlMin, ttlMax),
          size: rand(1.0, 2.2),
          rot: rand(0, Math.PI*2),
          spin: rand(-2.0, 2.0),
          color: palette[Math.floor(Math.random()*palette.length)],
        });
      }
    }

    function spawnSparkle(){
      const budget = clamp01((MAX_PARTICLES - particles.length) / MAX_PARTICLES);
      if(budget < 0.15) return;

      const { cx, cy, r } = getHeartCenter();
      const scale = (Math.min(r.width, r.height) / 40) * 1.05;
      const n = (Math.random() < 0.55) ? 1 : 2;

      for(let i=0;i<n;i++){
        const t = Math.random() * Math.PI * 2;
        const hp = heartPoint(t);
        const px = cx + hp.x * scale;
        const py = cy - hp.y * scale;

        const speed = rand(22, 60);
        const ang = rand(0, Math.PI*2);

        pushParticle({
          x: px + rand(-1, 1),
          y: py + rand(-1, 1),
          vx: Math.cos(ang) * speed / 60,
          vy: Math.sin(ang) * speed / 60,
          g: rand(20, 55) / 60,
          drag: rand(0.992, 0.998),
          life: 0,
          ttl: rand(0.55, 0.95),
          size: rand(0.7, 1.5),
          rot: rand(0, Math.PI*2),
          spin: rand(-1.6, 1.6),
          color: "rgba(255,255,255,1)",
        });
      }
    }

    function drawMiniHeart(x, y, s, rot, color, alpha){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.scale(s, s);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fill(miniHeartPath);
      ctx.restore();
    }

    let last = performance.now();

    function tick(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      // 拖尾雾层：更纯色背景 → 这里也用更纯的同色擦除
      ctx.save();
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgba(11,16,38,0.14)"; // ✅ 越小拖尾越长，越梦幻
      ctx.fillRect(0, 0, W, H);
      ctx.restore();

      // bokeh 更淡更少（纯色背景上也能有“气氛”）
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.shadowBlur = 26;
      ctx.shadowColor = "rgba(255,122,168,.14)";
      for(const b of bokeh){
        b.x += b.vx * 60 * dt;
        b.y += b.vy * 60 * dt;
        b.tw += 0.6 * dt;

        if(b.x < -80) b.x = W + 80;
        if(b.x > W + 80) b.x = -80;
        if(b.y < -80) b.y = H + 80;
        if(b.y > H + 80) b.y = -80;

        const a = b.a * (0.75 + 0.25 * Math.sin(b.tw));
        ctx.globalAlpha = a;
        ctx.fillStyle = "rgba(255,122,168,1)";
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // 星尘：稍微降频，让背景更“纯”
      if(Math.random() < 0.16) spawnSparkle();

      // 粒子主体
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.shadowBlur = 13;
      ctx.shadowColor = "rgba(255,122,168,.18)";

      for(let i = particles.length - 1; i >= 0; i--){
        const p = particles[i];
        p.life += dt;

        p.vx *= Math.pow(p.drag, 60*dt);
        p.vy *= Math.pow(p.drag, 60*dt);
        p.vy += p.g * dt;

        p.x += p.vx * 60 * dt;
        p.y += p.vy * 60 * dt;

        p.rot += p.spin * dt;

        const t = p.life / p.ttl;
        if(t >= 1){
          particles.splice(i, 1);
          continue;
        }

        const alpha = (1 - t) * (0.52 + 0.18*(1 - t));
        drawMiniHeart(p.x, p.y, p.size, p.rot, p.color, alpha);
      }

      ctx.restore();
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // 心跳喷粒（自动）
    const cycleMs = 1200;
    (function startHeartBeats(){
      function loop(){
        spawnBurst(0.26);
        setTimeout(() => spawnBurst(0.16), 200);
        setTimeout(loop, cycleMs);
      }
      loop();
    })();

    // resize 后更新 bokeh
    window.addEventListener('resize', () => initBokeh(), { passive:true });
  })();
  </script>
</body>
</html>
